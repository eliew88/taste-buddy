generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * User Model - Production Version
 */
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  image     String?
  password  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === RELATIONSHIPS ===
  recipes             Recipe[]
  favorites           Favorite[]
  ratings             Rating[]
  comments            Comment[]
  complimentsGiven    Compliment[] @relation("ComplimentsGiven")
  complimentsReceived Compliment[] @relation("ComplimentsReceived")
  
  // Following relationships
  following Follow[] @relation("UserFollowing")
  followers Follow[] @relation("UserFollowers")

  @@map("users")
}

/**
 * IngredientEntry Model - Structured ingredient with amount, unit, and ingredient
 */
model IngredientEntry {
  id         String @id @default(cuid())
  amount     Float
  unit       String?
  ingredient String
  
  // === RECIPE RELATIONSHIP ===
  recipeId String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  
  // === METADATA ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === INDEXES ===
  @@index([recipeId])
  @@index([ingredient])
  @@map("ingredient_entries")
}

/**
 * Recipe Model - Production Version
 */
model Recipe {
  id           String            @id @default(cuid())
  title        String
  description  String?
  // Structured ingredients instead of simple strings
  ingredients  IngredientEntry[]
  instructions String
  cookTime     String?
  servings     Int?
  difficulty   String            @default("easy")
  tags         String[]          @default([])
  image        String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  authorId     String
  
  // === RELATIONSHIPS ===
  author      User         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments    Comment[]
  favorites   Favorite[]
  ratings     Rating[]
  compliments Compliment[]

  @@index([authorId])
  @@index([difficulty])
  @@index([createdAt])
  @@index([tags], type: Gin)
  @@map("recipes")
}

/**
 * Favorite Model - Production Version
 */
model Favorite {
  id       String @id @default(cuid())
  userId   String
  recipeId String
  recipe   Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, recipeId])
  @@index([userId])
  @@index([recipeId])
  @@map("favorites")
}

/**
 * Rating Model - Production Version
 */
model Rating {
  id        String   @id @default(cuid())
  rating    Int      @default(1)
  userId    String
  recipeId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  recipe    Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, recipeId])
  @@index([recipeId])
  @@index([rating])
  @@map("ratings")
}

/**
 * Comment Model - Production Version
 */
model Comment {
  id         String   @id @default(cuid())
  content    String
  visibility String   @default("public")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  userId     String
  recipeId   String
  recipe     Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([recipeId])
  @@index([userId])
  @@index([visibility])
  @@index([createdAt])
  @@map("comments")
}

/**
 * Compliment Model - Private Chef Appreciation System
 */
model Compliment {
  id String @id @default(cuid())
  
  // === COMPLIMENT TYPE ===
  type String @default("message") // "message" or "tip"
  
  // === CONTENT ===
  message String // The compliment message
  
  // === TIP DETAILS (for future payment processing) ===
  tipAmount Decimal? // Amount in dollars (e.g., 2.50)
  currency  String   @default("USD")
  
  // === PAYMENT STATUS (for future implementation) ===
  paymentStatus String    @default("pending") // "pending", "completed", "failed"
  paymentId     String?   // External payment processor ID
  paymentDate   DateTime?
  
  // === PRIVACY OPTIONS ===
  isAnonymous Boolean @default(false) // Whether sender wants to remain anonymous
  
  // === TIMESTAMPS ===
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // === RELATIONSHIPS ===
  fromUserId String  // User giving the compliment
  toUserId   String  // Chef receiving the compliment  
  recipeId   String? // Optional: specific recipe that inspired the compliment
  
  fromUser User    @relation("ComplimentsGiven", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User    @relation("ComplimentsReceived", fields: [toUserId], references: [id], onDelete: Cascade)
  recipe   Recipe? @relation(fields: [recipeId], references: [id], onDelete: SetNull)
  
  // === INDEXES ===
  @@index([toUserId])
  @@index([fromUserId])
  @@index([recipeId])
  @@index([type])
  @@index([paymentStatus])
  @@index([createdAt])
  @@map("compliments")
}

/**
 * Follow Model - For TasteBuddies following system
 */
model Follow {
  id          String   @id @default(cuid())
  followerId  String   // User who is following
  followingId String   // User being followed
  createdAt   DateTime @default(now())
  
  // === RELATIONSHIPS ===
  follower  User @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)
  
  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

