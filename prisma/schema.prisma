/**
 * TasteBuddy Database Schema - SQLite Edition
 * 
 * This Prisma schema defines the database structure for the TasteBuddy recipe sharing platform
 * optimized for SQLite development. It uses JSON strings to store arrays since SQLite doesn't
 * support native array types.
 * 
 * Database Features:
 * - User authentication and profiles
 * - Recipe storage with JSON-based arrays
 * - Social features (favorites, ratings)
 * - SQLite-optimized data types
 * - Development-friendly single-file database
 * 
 * @file prisma/schema.prisma
 * @version 1.0.0 (SQLite)
 * @database SQLite
 * @created 2024
 */

// ===== PRISMA CONFIGURATION =====

/**
 * Prisma Client Generator
 * 
 * Generates the TypeScript client for database operations.
 * This creates type-safe database queries and mutations optimized for SQLite.
 */
generator client {
  provider = "prisma-client-js"
  // Optional: Generate client in custom location
  // output   = "./generated/client"
}

/**
 * SQLite Datasource Configuration
 * 
 * SQLite is perfect for development because:
 * - Single file database (no server setup required)
 * - Zero configuration
 * - Fast for small to medium datasets
 * - Easy backup and version control
 * - Cross-platform compatibility
 * 
 * Database file location: ./dev.db (in project root)
 */
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
  
  // Example DATABASE_URL values:
  // "file:./dev.db"           - Creates dev.db in project root
  // "file:./data/app.db"      - Creates in data subdirectory
  // "file::memory:"           - In-memory database (testing)
}

// ===== DATABASE MODELS =====

/**
 * User Model
 * 
 * Represents registered users of the TasteBuddy platform.
 * Stores authentication data and user preferences.
 * 
 * SQLite Considerations:
 * - Uses CUID for primary keys (better than auto-increment for distributed systems)
 * - Email uniqueness enforced at database level
 * - Optional fields use NULL in SQLite
 * - DateTime stored as ISO strings in SQLite
 * 
 * Relationships:
 * - One-to-many with Recipe (user can create many recipes)
 * - One-to-many with Favorite (user can favorite many recipes)
 * - One-to-many with Rating (user can rate many recipes)
 */
model User {
  // === PRIMARY KEY ===
  /** 
   * Unique identifier for the user
   * CUID format: c + timestamp + random = cjld2cyuq0000t3rmniod1foy
   * Better than UUID for database performance and URL friendliness
   */
  id String @id @default(cuid())

  // === AUTHENTICATION FIELDS ===
  /** 
   * User's email address (required, unique)
   * Used for authentication and communication
   * SQLite enforces uniqueness with automatic index
   * Validation should happen at application level
   */
  email String @unique

  /** 
   * User's display name (optional)
   * Shown on recipes and profile pages
   * NULL in SQLite when not provided
   * Can contain Unicode characters
   */
  name String?

  /** 
   * URL to user's profile image (optional)
   * Can be from OAuth providers or uploaded files
   * Should be HTTPS URLs for security
   * NULL in SQLite when not provided
   */
  image String?

  // === METADATA ===
  /** 
   * When the user account was created
   * Stored as ISO 8601 string in SQLite: "2024-01-15T10:30:00.000Z"
   * Automatically set on record creation
   * Used for account analytics and sorting
   */
  createdAt DateTime @default(now())

  /** 
   * When the user account was last updated
   * Automatically updated when any field changes
   * Useful for cache invalidation and sync
   */
  updatedAt DateTime @updatedAt

  // === RELATIONSHIPS ===
  /** 
   * Recipes created by this user
   * One-to-many relationship via authorId foreign key
   * CASCADE delete: When user deleted, all recipes deleted
   * Can be empty array for users who haven't shared recipes
   */
  recipes Recipe[]

  /** 
   * Recipes favorited by this user
   * One-to-many through Favorite join table
   * CASCADE delete: When user deleted, favorites removed
   * Used to build user's favorite recipe collection
   */
  favorites Favorite[]

  /** 
   * Ratings given by this user
   * One-to-many through Rating join table
   * CASCADE delete: When user deleted, ratings removed
   * Used for recommendation algorithms
   */
  ratings Rating[]

  // === TABLE CONFIGURATION ===
  /** 
   * Custom table name in SQLite database
   * Overrides default "User" to follow naming conventions
   */
  @@map("users")
}

/**
 * Recipe Model
 * 
 * Represents individual recipes shared on the platform.
 * Optimized for SQLite with JSON fields for array data.
 * 
 * SQLite Adaptations:
 * - ingredients: Stored as JSON string instead of native array
 * - tags: Stored as JSON string instead of native array
 * - instructions: Uses TEXT type for large content
 * - All searches use LIKE queries instead of full-text search
 * 
 * JSON Format Examples:
 * - ingredients: '["2 cups flour", "1 tsp salt", "3 eggs"]'
 * - tags: '["dessert", "chocolate", "easy"]'
 */
model Recipe {
  // === PRIMARY KEY ===
  /** 
   * Unique identifier for the recipe
   * CUID format for consistency with User model
   * Used in URLs: /recipes/[id]
   */
  id String @id @default(cuid())

  // === CORE CONTENT ===
  /** 
   * Recipe title/name (required)
   * Primary searchable field using SQLite LIKE queries
   * Should be descriptive and engaging
   * No length limit in SQLite (unlike VARCHAR)
   */
  title String

  /** 
   * Brief description of the recipe (optional)
   * Used in recipe cards and search results
   * Can include backstory, tips, or serving suggestions
   * NULL in SQLite when not provided
   */
  description String?

  /** 
   * List of ingredients with quantities (required)
   * 
   * SQLite Storage: JSON string format
   * Example: '["2 cups all-purpose flour", "1 cup butter, softened", "2 large eggs"]'
   * 
   * Application Usage:
   * - Parse with JSON.parse() when reading
   * - Store with JSON.stringify() when writing
   * - Use helper functions for type safety
   * 
   * Search: Uses SQLite LIKE '%ingredient%' for ingredient-based discovery
   */
  ingredients String // JSON array stored as string

  /** 
   * Step-by-step cooking instructions (required)
   * Can be paragraph format or numbered steps
   * Uses TEXT type in SQLite for unlimited length
   * Should include temperatures, timing, and techniques
   */
  instructions String

  // === RECIPE METADATA ===
  /** 
   * Estimated total cooking time (optional)
   * Free-form text: "30 mins", "1h 15m", "2 hours"
   * Used for filtering and meal planning
   * NULL in SQLite when not provided
   */
  cookTime String?

  /** 
   * Number of servings the recipe makes (optional)
   * Positive integer for scaling calculations
   * Used in nutrition calculations and meal planning
   * NULL in SQLite when not provided
   */
  servings Int?

  /** 
   * Difficulty level with default value
   * Controlled vocabulary: "easy", "medium", "hard"
   * Application should validate these values
   * Used for filtering and user guidance
   * Defaults to "easy" for better user experience
   */
  difficulty String @default("easy")

  /** 
   * Categorization tags (optional)
   * 
   * SQLite Storage: JSON string format
   * Example: '["dessert", "chocolate", "gluten-free", "quick"]'
   * 
   * Application Usage:
   * - Parse with JSON.parse() when reading
   * - Store with JSON.stringify() when writing
   * - Use for filtering and recipe discovery
   * - Defaults to empty array: "[]"
   * 
   * Search: Uses SQLite LIKE '%tag%' for tag-based filtering
   */
  tags String @default("[]") // JSON array stored as string

  /** 
   * URL to recipe hero image (optional)
   * Should be HTTPS URLs for security
   * Can be uploaded files or external URLs
   * Used in recipe cards and detail pages
   * NULL in SQLite when not provided
   */
  image String?

  // === TIMESTAMPS ===
  /** 
   * When the recipe was created
   * Used for "newest recipes" sorting
   * ISO 8601 format in SQLite
   */
  createdAt DateTime @default(now())

  /** 
   * When the recipe was last updated
   * Tracks content modifications
   * Useful for cache invalidation
   */
  updatedAt DateTime @updatedAt

  // === AUTHOR RELATIONSHIP ===
  /** 
   * Foreign key to the recipe author
   * Required field - every recipe must have an author
   * References User.id field
   */
  authorId String

  /** 
   * Author of the recipe
   * Many-to-one relationship with User
   * CASCADE delete: When author deleted, recipes deleted
   * Used to display author info and link to profile
   */
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // === SOCIAL FEATURES ===
  /** 
   * Users who have favorited this recipe
   * One-to-many through Favorite join table
   * Used to build user favorite collections
   * Count used for popularity metrics
   */
  favorites Favorite[]

  /** 
   * Ratings given to this recipe
   * One-to-many through Rating join table
   * Used to calculate average rating and popularity
   * Individual ratings used for recommendations
   */
  ratings Rating[]

  // === TABLE CONFIGURATION ===
  /** 
   * Custom table name in SQLite database
   */
  @@map("recipes")
}

/**
 * Favorite Model
 * 
 * Join table implementing many-to-many relationship between Users and Recipes.
 * Represents user's favorite recipe collections.
 * 
 * SQLite Features:
 * - Composite unique index on (userId, recipeId)
 * - Foreign key constraints with CASCADE delete
 * - Efficient queries for user favorites and recipe popularity
 */
model Favorite {
  // === PRIMARY KEY ===
  /** 
   * Technical primary key for SQLite requirements
   * CUID format for consistency
   * Not typically used in application logic
   */
  id String @id @default(cuid())

  // === FOREIGN KEYS ===
  /** 
   * ID of the user who favorited the recipe
   * References User.id
   * Part of composite unique constraint
   */
  userId String

  /** 
   * ID of the recipe that was favorited
   * References Recipe.id  
   * Part of composite unique constraint
   */
  recipeId String

  // === RELATIONSHIPS ===
  /** 
   * User who created this favorite
   * Many-to-one relationship with CASCADE delete
   * When user deleted, all their favorites removed
   */
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /** 
   * Recipe that was favorited
   * Many-to-one relationship with CASCADE delete
   * When recipe deleted, all its favorites removed
   */
  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  // === CONSTRAINTS ===
  /** 
   * Composite unique constraint
   * Prevents duplicate favorites (same user + recipe)
   * Creates automatic index for efficient queries
   * Enables fast lookups like "has user X favorited recipe Y?"
   */
  @@unique([userId, recipeId])

  /** 
   * Custom table name in SQLite database
   */
  @@map("favorites")
}

/**
 * Rating Model
 * 
 * Join table implementing user ratings for recipes.
 * Stores 1-5 star ratings with business constraints.
 * 
 * SQLite Features:
 * - Integer storage for rating values
 * - Composite unique index prevents multiple ratings per user per recipe
 * - Efficient aggregation for average ratings
 */
model Rating {
  // === PRIMARY KEY ===
  /** 
   * Technical primary key for SQLite requirements
   * CUID format for consistency
   * Not typically used in application logic
   */
  id String @id @default(cuid())

  // === RATING DATA ===
  /** 
   * Star rating value (1-5 scale)
   * Integer type for efficient storage and calculation
   * Default value of 1 (minimum rating)
   * Application should enforce 1-5 range validation
   * Used to calculate recipe average ratings
   */
  rating Int @default(1)

  // === FOREIGN KEYS ===
  /** 
   * ID of the user who gave the rating
   * References User.id
   * Part of composite unique constraint
   */
  userId String

  /** 
   * ID of the recipe that was rated
   * References Recipe.id
   * Part of composite unique constraint
   */
  recipeId String

  // === RELATIONSHIPS ===
  /** 
   * User who created this rating
   * Many-to-one relationship with CASCADE delete
   * When user deleted, all their ratings removed
   */
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  /** 
   * Recipe that was rated
   * Many-to-one relationship with CASCADE delete
   * When recipe deleted, all its ratings removed
   */
  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)

  // === CONSTRAINTS ===
  /** 
   * Composite unique constraint
   * Ensures one rating per user per recipe
   * User can update existing rating but not create duplicates
   * Creates automatic index for efficient queries
   */
  @@unique([userId, recipeId])

  /** 
   * Custom table name in SQLite database
   */
  @@map("ratings")
}

// ===== SQLITE-SPECIFIC NOTES =====

/**
 * SQLite ADVANTAGES for TasteBuddy Development:
 * 
 * 1. Zero Setup:
 *    - No database server installation required
 *    - Single file database (dev.db)
 *    - Works immediately with Prisma
 * 
 * 2. Development Friendly:
 *    - Easy to backup (copy one file)
 *    - Version control friendly
 *    - Fast for development datasets
 *    - Cross-platform compatibility
 * 
 * 3. Prisma Integration:
 *    - Full Prisma feature support
 *    - Type-safe queries
 *    - Migration system works perfectly
 * 
 * SQLite LIMITATIONS (addressed in this schema):
 * 
 * 1. No Native Arrays:
 *    - Solution: JSON strings for ingredients/tags
 *    - Helper functions convert between arrays and JSON
 *    - Search using LIKE queries on JSON content
 * 
 * 2. Limited Full-Text Search:
 *    - Solution: Use LIKE queries with indexes
 *    - Consider FTS5 extension for production
 * 
 * 3. No Advanced Types:
 *    - All types mapped to SQLite primitives
 *    - DateTime as ISO strings
 *    - JSON as TEXT
 * 
 * PERFORMANCE OPTIMIZATIONS:
 * 
 * 1. Automatic Indexes:
 *    - Primary keys (@id)
 *    - Unique constraints (@unique)
 *    - Foreign keys (relation fields)
 * 
 * 2. Query Patterns:
 *    - Use Prisma's include for eager loading
 *    - Paginate large result sets
 *    - Index frequently queried fields
 * 
 * 3. JSON Field Queries:
 *    - Use LIKE for simple searches: WHERE ingredients LIKE '%flour%'
 *    - Parse JSON in application for complex filtering
 *    - Consider denormalizing for frequently queried tags
 * 
 * PRODUCTION MIGRATION PATH:
 * 
 * When ready for production with PostgreSQL:
 * 1. Change datasource provider to "postgresql"
 * 2. Update DATABASE_URL to PostgreSQL connection
 * 3. Change ingredients/tags from String to String[]
 * 4. Update helper functions to handle native arrays
 * 5. Migrate data using custom scripts
 * 
 * This SQLite schema provides a perfect development environment
 * while maintaining the same application API for easy migration!
 */